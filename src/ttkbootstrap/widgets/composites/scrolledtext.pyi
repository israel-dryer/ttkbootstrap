"""Type stubs for the composite ScrolledText widget."""
import tkinter
from typing import Any, Literal, Optional, Tuple, overload

from ttkbootstrap.widgets.primitives.frame import Frame
from ttkbootstrap.widgets.primitives.scrollbar import Scrollbar

_TextIndex = str | float


class ScrolledText(Frame):
    """A text widget with configurable scrollbars and mouse wheel support."""

    vertical_scrollbar: Scrollbar
    horizontal_scrollbar: Scrollbar

    def __init__(
            self,
            master: Optional[tkinter.Misc] = None,
            padding: int = 0,
            direction: Literal['horizontal', 'vertical', 'both'] = 'vertical',
            show_scrollbar: Literal['always', 'never', 'on-hover', 'on-scroll'] = 'always',
            autohide_delay: int = 1000,
            scrollbar_style: str = 'default',
            **kwargs: Any,
    ) -> None:
        self._text: tkinter.Text = None
        ...

    @property
    def text(self) -> tkinter.Text: ...

    def delete(self, index1: _TextIndex, index2: Optional[_TextIndex] = None) -> None: ...

    @overload
    def get(self, index1: _TextIndex, index2: None = None) -> str: ...

    @overload
    def get(self, index1: _TextIndex, index2: _TextIndex) -> str: ...

    def insert(self, index: _TextIndex, chars: str, *args: str | Tuple[str, ...]) -> None: ...

    def replace(self, index1: _TextIndex, index2: _TextIndex, chars: str, *args: str | Tuple[str, ...]) -> None: ...

    def index(self, index: _TextIndex) -> str: ...

    def see(self, index: _TextIndex) -> None: ...

    def compare(
            self, index1: _TextIndex, op: Literal['<', '<=', '==', '>=', '>', '!='], index2: _TextIndex) -> bool: ...

    def bbox(self, index: _TextIndex) -> Optional[Tuple[int, int, int, int]]: ...

    def dlineinfo(self, index: _TextIndex) -> Optional[Tuple[int, int, int, int, int]]: ...

    def search(
            self,
            pattern: str,
            index: _TextIndex,
            stopindex: Optional[_TextIndex] = None,
            forwards: Optional[bool] = None,
            backwards: Optional[bool] = None,
            exact: Optional[bool] = None,
            regexp: Optional[bool] = None,
            nocase: Optional[bool] = None,
            count: Optional[tkinter.Variable] = None,
            elide: Optional[bool] = None,
    ) -> str: ...

    def mark_gravity(self, markName: str, direction: Optional[Literal['left', 'right']] = None) -> Optional[
        Literal['left', 'right']]: ...

    def mark_names(self) -> Tuple[str, ...]: ...

    def mark_set(self, markName: str, index: _TextIndex) -> None: ...

    def mark_unset(self, *markNames: str) -> None: ...

    def mark_next(self, index: _TextIndex) -> Optional[str]: ...

    def mark_previous(self, index: _TextIndex) -> Optional[str]: ...

    def tag_add(self, tagName: str, index1: _TextIndex, *args: _TextIndex) -> None: ...

    def tag_unbind(self, tagName: str, sequence: str, funcid: Optional[str] = None) -> None: ...

    def tag_bind(
            self, tagName: str, sequence: Optional[str], func: Optional[Any], add: Optional[bool] = None) -> str: ...

    def tag_cget(self, tagName: str, option: str) -> Any: ...

    def tag_configure(self, tagName: str, cnf: Optional[dict[str, Any]] = None, **kw: Any) -> Optional[Any]: ...

    tag_config = tag_configure

    def tag_delete(self, *tagNames: str) -> None: ...

    def tag_lower(self, tagName: str, belowThis: Optional[str] = None) -> None: ...

    def tag_names(self, index: Optional[_TextIndex] = None) -> Tuple[str, ...]: ...

    def tag_nextrange(self, tagName: str, index1: _TextIndex, index2: Optional[_TextIndex] = None) -> Tuple[
        str, ...]: ...

    def tag_prevrange(self, tagName: str, index1: _TextIndex, index2: Optional[_TextIndex] = None) -> Tuple[
        str, ...]: ...

    def tag_raise(self, tagName: str, aboveThis: Optional[str] = None) -> None: ...

    def tag_ranges(self, tagName: str) -> Tuple[str, ...]: ...

    def tag_remove(self, tagName: str, index1: _TextIndex, index2: Optional[_TextIndex] = None) -> None: ...

    def edit_modified(self, arg: Optional[bool] = None) -> Optional[bool]: ...

    def edit_redo(self) -> None: ...

    def edit_reset(self) -> None: ...

    def edit_separator(self) -> None: ...

    def edit_undo(self) -> None: ...

    def image_cget(self, index: _TextIndex, option: str) -> Any: ...

    def image_configure(self, index: _TextIndex, cnf: Optional[dict[str, Any]] = None, **kw: Any) -> Optional[Any]: ...

    def image_create(
            self,
            index: _TextIndex,
            cnf: dict[str, Any] = ...,
            **kw: Any,
    ) -> str: ...

    def image_names(self) -> Tuple[str, ...]: ...

    def window_cget(self, index: _TextIndex, option: str) -> Any: ...

    def window_configure(self, index: _TextIndex, cnf: Optional[dict[str, Any]] = None, **kw: Any) -> Optional[Any]: ...

    def window_create(
            self,
            index: _TextIndex,
            cnf: dict[str, Any] = ...,
            **kw: Any,
    ) -> str: ...

    def window_names(self) -> Tuple[str, ...]: ...

    def dump(
            self,
            index1: _TextIndex,
            index2: Optional[_TextIndex] = None,
            command: Optional[Any] = None,
            **kw: Any,
    ) -> list[Tuple[str, str, str]] | None: ...

    def peer_create(self, newPathName: str | tkinter.Text, cnf: dict[str, Any] = {}, **kw: Any) -> None: ...

    def peer_names(self) -> Tuple[tkinter.Text, ...]: ...

    def count(self, index1: _TextIndex, index2: _TextIndex, *options: str) -> Optional[int | Tuple[int, ...]]: ...

    def scan_mark(self, x: int, y: int) -> None: ...

    def scan_dragto(self, x: int, y: int) -> None: ...

    def yview_moveto(self, fraction: float) -> None: ...

    def yview_scroll(self, number: int, what: Literal['units', 'pages']) -> None: ...

    @overload
    def yview(self) -> Tuple[float, float]: ...

    @overload
    def yview(self, *args: Any) -> None: ...

    def xview_moveto(self, fraction: float) -> None: ...

    def xview_scroll(self, number: int, what: Literal['units', 'pages']) -> None: ...

    @overload
    def xview(self) -> Tuple[float, float]: ...

    @overload
    def xview(self, *args: Any) -> None: ...
